###  JVM内存结构
#### Java虚拟机的内存空间分为5个部分：
-   程序计数器
-   Java虚拟机栈
-   本地方法栈
-   方法区
-   堆

![image.png](https://i.loli.net/2021/01/24/jYg5kVTmaHIRdcp.png)

> JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。

#### 程序计数器（线程私有的） 

##### 定义：程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为Undefined

##### 作用：
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
- 当多线程时，因为程序计数器时每个线程都存在，所以当线程切换回来时，就可以知道上次线程执行到哪里了

##### 特点：
-  是一块很小的内存区域，不会出现OutOfMemoryError的内存区域
-  线程私有的，每条线程都有自己的程序计数器
-  生命周期：随着线程的创建而创建，随着线程的结束而销毁

##### Java虚拟机栈
##### 定义：Java 虚拟机栈是描述 Java 方法运行过程的内存模型。Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：
-  局部变量表
-  操作数栈
-  动态链接
-  方法出口信息

![image.png](https://i.loli.net/2021/01/24/o6HAOd2kntLDBl5.png)

##### 特点：

-   局部变量表随着栈帧的创建而创建，大小在编译时确定，创建时只需要事先分配先规定的大小即可。在方法运行时，局部变量表的大小不会改变。
-   Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError
    -  StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。
    -  OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。

-   Java虚拟机栈也是线程私有的，随着线程创建而创建，随着线程的结束而销毁
-   出现StackOverFlowError 时，内存空间可能还有很多

#### 本地方法栈

##### 定义：本地方法栈是为JVM运行的Native方法准备的空间，由于很多Native方法都是用C语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型

#### 堆
##### 定义：堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中

##### 特点：

-   线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个
-   在虚拟机启动时创建
-   垃圾回收的主要场所
-   分为新生代（Eden区，From Survior, To Survivor）、老年代
-   堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。

##### 方法区

##### 定义：Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：
- 已经被虚拟机加载的类信息
- 常量
- 静态变量
- 即时编译器编译后的代码

##### 特点:
-   线程共享，方法区是堆的逻辑分区，是线程共享的，整个虚拟机只有一个方法区
-   称为永久代
-   内存回收率低，因为处于永久代的信息大都需要长期存在，主要的回收目标是：对常量池的回收、类型的卸载
-   允许固定大小或者动态扩展

##### 运行时常量池
-   方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中
-   当类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行时常量池中

#### 直接内存（堆外内存）
直接内存是除Java虚拟机以外的内存，但也可能被Java使用

##### 操作直接内存

-   在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。
-   直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。

##### 直接内存与堆内存比较

- 直接内存申请空间耗费更高的性能
- 直接内存读取 IO 的性能要优于普通的堆内存。
- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO堆内存作用链：
- 本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO
